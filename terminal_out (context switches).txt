My understanding of the bug:
MessageReciever (on certain runs) gets blocked on recvfrom forever. This is happening (partially) because recvfrom makes an I/O request, thus causing the thread to sleep. The question is, why does it never return? The bug is not caused by anything mutex/cond_var related on the MessageReceiver thread because it never even approaches its critical section. 

QUESTIONS
-Is it possible for socket connection itself to sometimes work sometimes not work (even though using same settings)? If so, is it possible to check for this condition (either directly or indirectly) and re-configure the socket in hopes of it working this time (e.g., would it be a terrible idea to have while loop that reconfigures socket until "connection" is good?)

-The textbook says a non-voluntary context switch occurs when the process's time slice has expired, or it was pre-empted for a higher priority process (aren't those basically the same thing?)

-What exactly is an involuntary context switch vs voluntary. I'm assuming that when a thread is on a wait that this causes a voluntary context switch

-Since MessageReceiver has no involuntary context switches, can it be concluded that therefore it is not being put to sleep due to another process hogging it?

-Both MessageReceiver and both KeyboardReceiver threads don't have any involuntary context switches? What might be the reason for that?

-And on the contrary, both MessageSender and Printer threads have involuntary and voluntary context switches. Why?

-Idea: What if I modified MessageSender to send null messages when there's nothing to send? Would that work to prevent MessageReceiver from being permanently blocked? If so, what period of time would you recommend between null messages such that it doesn't waste the CPU too much, but allows MessageReceiver to remain responsive? 

-Is it possible that thread entry order is causing the error? If so, would it be a bad idea to enforce a certain order of entry?

-Is there a way to make recvfrom timeout? That would be handy. Am I allowed to do that?

-Is it possible for MessageSender in Process A to signal MessageReceiver in Process B? If so, any hints?

-Is there a function other than recvfrom that I could use? One that doesn't block until it receives something, but rather checks repeatedly for a message? Or could I use a different form of message passing as a way of signalling that a new message has arrived, and when that happens, call recvfrom? Can recvfrom get messages after it has been sent, or does it have to receive it in real time?



PROCESS A (Could receive)
KeyboardReceiver: #5229
MessageSender: #5230
MessageReceiver: #5231
Printer: #5232

PROCESS B (Could send but not receive)
KeyboardReceiver: #5224
MessageSender: #5225
MessageReceiver: #5226
Printer: #5227

**********************************

Process B - MessageReceiver: #5226
State:	S (sleeping)
voluntary_ctxt_switches:	1
nonvoluntary_ctxt_switches:	0

Process A - MessageReceiver: #5231
State:	S (sleeping)
voluntary_ctxt_switches:	4
nonvoluntary_ctxt_switches:	0

Process A - MessageSender: #5230
Name:	s-talk
State:	S (sleeping)
voluntary_ctxt_switches:	3
nonvoluntary_ctxt_switches:	4

Process B - MessageSender: #5225
State:	S (sleeping)
voluntary_ctxt_switches:	5
nonvoluntary_ctxt_switches:	5

Process B - Printer: #5227
ben@ubuntu:~$ cat /proc/5227/status
State:	S (sleeping)
voluntary_ctxt_switches:	1
nonvoluntary_ctxt_switches:	0

Process A - Printer: #5232
State:	S (sleeping)
voluntary_ctxt_switches:	6
nonvoluntary_ctxt_switches:	4

Process B - KeyboardReceiver: #5224
State:	S (sleeping)
voluntary_ctxt_switches:	6
nonvoluntary_ctxt_switches:	0

Process A - KeyboardReceiver: #5229
State:	S (sleeping)
voluntary_ctxt_switches:	5
nonvoluntary_ctxt_switches:	0